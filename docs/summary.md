# GitHub Project Portfolio Management Plan
**Generated:** 2025-11-12
**User:** softwarewrighter
**Total Repositories:** 56

## Executive Summary

This document provides an inventory of all GitHub projects under the `softwarewrighter` account and outlines a comprehensive management strategy for using AI coding agents to enhance, maintain, and validate these projects.

## Project Inventory

### Recently Active Projects (Last 30 Days)

1. **crudibase** (Public)
   - Description: React/express app for WikiBase and other APIs as a CRUD app with sqlite (fork)
   - Language: TypeScript
   - License: MIT
   - Last Updated: Nov 11, 2025
   - Status: Public fork with 1 fork

2. **cruditrack** (Private)
   - Description: ReactJS work tracking app
   - Language: TypeScript
   - License: MIT
   - Last Updated: Nov 11, 2025

3. **assist** (Private)
   - Description: git repo status reporting assistant Rust CLI
   - Language: Rust
   - Last Updated: Nov 11, 2025

4. **one-armed** (Private)
   - Description: A slot-machine simulator
   - Language: Rust
   - Last Updated: Nov 10, 2025

5. **ask** (Private)
   - Description: CLI to ask an LLM a question
   - Language: Rust
   - Last Updated: Nov 10, 2025

6. **rag-demo** (Public)
   - Description: Rust demo of RAG using Qdrant
   - Language: Rust
   - License: MIT
   - Last Updated: Nov 10, 2025

7. **game-lib** (Private)
   - Description: Rust game library
   - Language: Rust
   - Last Updated: Nov 10, 2025

8. **emacs-ai-study-group** (Public)
   - Description: for sharing documents with the Emacs AI Study Group discord server
   - Language: Emacs Lisp
   - License: MIT
   - Last Updated: Nov 7, 2025
   - Status: Fork from wrightmikea/emacs-ai-study-group

9. **aikan** (Private)
   - Description: AI-orchestration Kanban project
   - Language: Rust
   - Last Updated: Nov 6, 2025

10. **emacs-agent** (Public)
    - Description: Emacs AI coding agent package
    - Last Updated: Nov 5, 2025

11. **pdf2md** (Public)
    - Description: Rust CLI to extract text from a PDF to create a similar markdown file
    - Language: Rust
    - License: MIT
    - Last Updated: Nov 5, 2025

12. **neural-network-examples-rs** (Public)
    - Description: Rust implementation of various neural networks with visualizations and examples
    - Language: Rust
    - License: MIT
    - Last Updated: Nov 1, 2025
    - Status: Fork from alelouis/Feed-Forward-Neural-Network

13. **umap** (Public)
    - Description: Rust CLI to visualize dimension redirection via UMAP
    - Language: Rust
    - License: MIT
    - Last Updated: Nov 1, 2025

14. **demo-ibm-1130-system** (Public)
    - Description: Yew web app to visualize an emulated IBM 1130 system
    - Language: Rust
    - License: MIT
    - Last Updated: Oct 31, 2025

15. **S1130** (Public)
    - Description: IBM 1130 Emulator in C#
    - Language: C#
    - Last Updated: Oct 24, 2025
    - Status: Fork from semuhphor/S1130

16. **fractal-gpu** (Private)
    - Description: Rust demo of fractal zooming using CPU-only, 1 GPU, or 2 GPUs
    - Language: Rust
    - Last Updated: Oct 23, 2025

17. **mp3-to-ogg** (Private)
    - Description: Rust CLI to compress music files individually or in a directory tree
    - Language: Rust
    - Last Updated: Oct 21, 2025

18. **favicon** (Private)
    - Description: generates simple favicons from specified text and colors
    - Language: Emacs Lisp
    - Last Updated: Oct 15, 2025

### AI & Machine Learning Projects

- **rag-demo**: RAG implementation using Qdrant
- **neural-network-examples-rs**: Neural network examples with visualizations
- **umap**: UMAP dimension reduction visualization
- **SpikingBrain-7B**: Spiking neural network model (fork)
- **bdh**: Baby Dragon Hatchling architecture and code (fork)
- **train-hrm**: CLI framework to train and use an HRM
- **ARPB**: AI-Rust-Python-Blender3D integration

### AI Tooling & Agent Projects

- **emacs-agent**: Emacs AI coding agent package
- **aikan**: AI-orchestration Kanban project
- **emacs-ai-api**: Emacs configuration with Rust CLI tools for managing multiple local and cloud LLM access
- **ask**: CLI to ask an LLM a question
- **mcp-unified**: CLI choreographer with open tool-using AI, custom MCP server, and distributed agents
- **open_agent_cli_fork**: A Rust port of a Go clone of Claude Code
- **mcp-server-fork**: MCP server implementation
- **mcp_agent_fork**: MCP agent implementation
- **lucy-gradio**: Python app gradio UI for remote-agents
- **proact**: A CLI tool to generate documents proactively for coding agents

### CRUD & Data Management Projects

- **crudibase**: React/express app for WikiBase and other APIs
- **cruditrack**: ReactJS work tracking app
- **bookmarks**: Rust CRUD app with tabbed views of bookmark lists

### System Utilities (Rust CLI Tools)

- **assist**: git repo status reporting assistant
- **pdf2md**: PDF to markdown converter
- **fsim**: Find similar strings using fuzzy algorithms
- **svcmon**: Monitor configured hosts and service ports
- **disk-catalog**: CLI to build a catalog of disk info
- **simple-sync**: CLI to share system configuration info with peers
- **mp3-to-ogg**: Music file compression utility

### Games & Simulations

- **one-armed**: Slot-machine simulator
- **game-lib**: Rust game library
- **slots-roulette**: Rust/WASM static web app game
- **Chaparral**: Chaparral-inspired idler game
- **demo-ibm-1130-system**: IBM 1130 system emulator visualization
- **S1130**: IBM 1130 Emulator in C#

### Emacs Projects

- **emacs-agent**: AI coding agent package
- **emacs-ai-study-group**: Documents for Emacs AI Study Group
- **emacs-ai-api**: Multi-LLM management configuration
- **emacs-rust-menus**: Rust/WASM GUI leveraging emacs runtime
- **favicon**: Favicon generator

### Hardware/Embedded Projects

- **sensor_data**: Sensor data handling
- **i2c-cli**: I2C command-line interface
- **mpu6050-util**: MPU6050 sensor utility
- **receiver**: Receiver implementation
- **rtc_multiplexer**: i2c multiplexer sandbox
- **embeddedapps**: Embedded applications (fork)
- **bmp280**: embedded-hal compatible driver for bmp280 pressure sensor (fork)

### Infrastructure & System Projects

- **hw_sw_catalog**: Distributed catalog of hardware and software with discovery tools
- **mesh-cat**: Mesh of databases for eventually consistent catalog
- **tracking**: Contract work tracking
- **logic-effects**: Distributed dynamic container system using composible logic
- **ortho**: Orthogonal CRUD subfeature framework/container

### Aikan Ecosystem (Modular Components)

- **aikan**: Main AI-orchestration Kanban project
- **aikan-templates**: Template support crate
- **aikan-errors**: Error support crate
- **aikan-validation**: Schema/rules/dependencies validation crate
- **aikan-config**: Configuration support crate
- **shared-git**: Low-level git abstractions

### Other Projects

- **BMAD-METHOD**: Breakthrough Method for Agile AI Driven Development (fork)
- **cljs**: ClojureScript sandbox for coding agent use

## Technology Stack Analysis

### Primary Languages
1. **Rust** (35+ projects) - Dominant language for CLIs, system tools, and performance-critical applications
2. **TypeScript/JavaScript** (5+ projects) - Web applications and React-based projects
3. **Python** (4 projects) - ML/AI projects, Blender integration, Gradio UIs
4. **Emacs Lisp** (4 projects) - Editor customization and AI integration
5. **C#** (1 project) - IBM 1130 emulator
6. **Shell/Makefile** (2 projects) - Build and deployment scripts

### Key Technologies
- **Web Frameworks**: React, Express, Yew (Rust), WASM
- **AI/ML**: Qdrant (RAG), UMAP, Neural Networks, LLM APIs
- **Databases**: SQLite, various mesh databases
- **Emacs Integration**: Custom packages, AI agents
- **Embedded**: I2C, sensor interfaces, embedded-hal
- **MCP (Model Context Protocol)**: Multiple implementations and servers

## AI Coding Agent Management Strategy

### 1. Project Categorization Framework

#### Tier 1: Active Development (High Priority)
Projects actively maintained or under recent development:
- crudibase, cruditrack, assist, ask, rag-demo
- aikan and its modular components
- emacs-agent, emacs-ai-api

**AI Agent Tasks:**
- Feature additions and enhancements
- Bug fixes and optimization
- Documentation improvements
- Test coverage expansion

#### Tier 2: Maintenance Mode (Medium Priority)
Stable projects needing periodic updates:
- pdf2md, umap, game-lib
- Various CLI utilities (svcmon, fsim, disk-catalog)
- Embedded projects

**AI Agent Tasks:**
- Dependency updates
- Security patches
- Bug fixes
- Documentation maintenance

#### Tier 3: Archive/Reference (Low Priority)
Older projects or forks used for reference:
- Projects last updated in 2024
- Forks without significant modifications
- Experimental/sandbox projects

**AI Agent Tasks:**
- Security audits
- README updates
- Archival documentation

### 2. AI Agent Workflows

#### Feature Development Workflow
1. **Planning Phase**
   - Agent analyzes project structure
   - Reviews existing documentation
   - Creates feature implementation plan
   - Identifies dependencies and impacts

2. **Implementation Phase**
   - Generates code following project conventions
   - Creates/updates tests
   - Updates documentation
   - Follows language-specific best practices

3. **Validation Phase**
   - Runs test suite
   - Performs static analysis
   - Checks code coverage
   - Validates documentation completeness

4. **Review Phase**
   - Creates pull request with detailed description
   - Highlights changes and rationale
   - Suggests reviewer focus areas

#### Bug Fix Workflow
1. **Issue Analysis**
   - Agent examines bug report
   - Reproduces issue if possible
   - Identifies root cause
   - Proposes fix approach

2. **Fix Implementation**
   - Implements minimal fix
   - Adds regression tests
   - Updates related documentation

3. **Verification**
   - Runs full test suite
   - Validates fix effectiveness
   - Checks for side effects

#### Validation/Analysis Workflow
1. **Code Quality Analysis**
   - Static analysis (clippy for Rust, eslint for JS/TS)
   - Code complexity metrics
   - Technical debt identification
   - Security vulnerability scanning

2. **Documentation Analysis**
   - README completeness check
   - API documentation coverage
   - Example code validity
   - Installation instructions verification

3. **Dependency Analysis**
   - Outdated dependency identification
   - Security advisory checking
   - License compatibility verification
   - Breaking change detection

4. **Test Coverage Analysis**
   - Coverage metrics generation
   - Untested code path identification
   - Test quality assessment
   - Integration test gap analysis

### 3. Agent-Friendly Project Setup

#### Standard Project Structure
Each project should include:
```
project/
├── .ai/
│   ├── context.md          # Project overview for AI agents
│   ├── conventions.md      # Coding conventions and standards
│   ├── architecture.md     # System architecture documentation
│   └── tasks.md           # Current tasks and priorities
├── docs/
│   ├── README.md          # User-facing documentation
│   ├── API.md             # API documentation (if applicable)
│   └── CONTRIBUTING.md    # Contribution guidelines
├── tests/
│   ├── unit/
│   ├── integration/
│   └── fixtures/
└── .github/
    └── workflows/
        ├── ci.yml         # Continuous integration
        └── agent-tasks.yml # Automated agent tasks
```

#### Agent Context Files
Create `.ai/context.md` in each project with:
- Project purpose and goals
- Key architectural decisions
- Technology choices and rationale
- Current development priorities
- Known issues and technical debt
- Testing strategy
- Deployment process

### 4. Automation & CI/CD Integration

#### GitHub Actions Workflows
1. **Agent-Triggered Workflows**
   - Automated testing on PR
   - Dependency updates
   - Security scanning
   - Documentation generation

2. **Quality Gates**
   - Minimum test coverage requirements
   - Static analysis passing
   - No high-severity vulnerabilities
   - Documentation completeness

3. **Agent Feedback Loop**
   - CI results fed back to AI agent
   - Automated fix suggestions
   - Learning from past issues

### 5. Project-Specific AI Agent Strategies

#### Rust Projects
- Use `cargo clippy` for linting
- Run `cargo test` for validation
- Check `cargo audit` for security
- Use `cargo doc` for documentation
- Apply `rustfmt` for formatting

#### TypeScript/React Projects
- Use `eslint` and `prettier`
- Run `npm test` or `yarn test`
- Check `npm audit` for vulnerabilities
- Use `tsc` for type checking
- Generate API docs with TypeDoc

#### Python Projects
- Use `ruff` or `pylint` for linting
- Run `pytest` for testing
- Check with `bandit` for security
- Use `black` for formatting
- Generate docs with Sphinx or mkdocs

#### Emacs Lisp Projects
- Use `package-lint` for linting
- Run `ert` tests
- Check byte-compilation warnings
- Document with standard Emacs conventions

### 6. Cross-Project Management

#### Portfolio Dashboard
Create a central dashboard project that:
- Tracks status of all repositories
- Monitors CI/CD health
- Aggregates security advisories
- Displays test coverage metrics
- Shows documentation completeness
- Lists open issues and PRs

#### Shared Tooling
- Common `.ai/` templates
- Shared GitHub Actions workflows
- Unified linting configurations
- Standard testing frameworks
- Documentation templates

#### Dependency Management
- Weekly automated dependency updates
- Security advisory monitoring
- Breaking change detection
- Compatibility testing across projects

### 7. Agent Interaction Protocols

#### Task Assignment
AI agents should be assigned tasks through:
1. **GitHub Issues** - Standard issue templates with AI-agent label
2. **Project Boards** - Automated Kanban boards for agent tasks
3. **Task Files** - `.ai/tasks.md` for project-specific work queues

#### Communication Standards
- Clear, structured prompts
- Comprehensive context in task descriptions
- Explicit acceptance criteria
- Reference to relevant documentation
- Links to related issues/PRs

#### Progress Tracking
- Regular status updates in PRs
- Checkpoint commits with descriptive messages
- Clear documentation of decisions made
- Identification of blockers requiring human input

### 8. Validation & Quality Assurance

#### Multi-Level Validation
1. **Automated Validation**
   - Unit tests pass
   - Integration tests pass
   - Static analysis clean
   - No security vulnerabilities
   - Documentation builds successfully

2. **Agent Self-Review**
   - Code follows conventions
   - Changes are minimal and focused
   - Tests adequately cover changes
   - Documentation is complete

3. **Human Review Triggers**
   - Architecture changes
   - Breaking API changes
   - Security-sensitive code
   - Novel algorithms or approaches

#### Quality Metrics
Track and improve:
- Test coverage percentage
- Static analysis warning count
- Documentation coverage
- Issue resolution time
- PR merge time
- Code churn rate

## Implementation Roadmap

### Phase 1: Foundation (Weeks 1-2)
- [ ] Create `.ai/` directories in all active projects
- [ ] Write context files for Tier 1 projects
- [ ] Set up central portfolio dashboard
- [ ] Create standard GitHub Actions workflows

### Phase 2: Automation (Weeks 3-4)
- [ ] Implement automated dependency updates
- [ ] Set up security scanning
- [ ] Configure quality gates
- [ ] Create issue templates for AI agents

### Phase 3: Agent Integration (Weeks 5-6)
- [ ] Deploy AI agents for Tier 1 projects
- [ ] Train agents on project conventions
- [ ] Begin automated maintenance tasks
- [ ] Monitor and refine agent performance

### Phase 4: Optimization (Weeks 7-8)
- [ ] Expand to Tier 2 projects
- [ ] Refine agent workflows based on learnings
- [ ] Improve documentation and context
- [ ] Establish cross-project standards

### Phase 5: Scale (Ongoing)
- [ ] Full portfolio coverage
- [ ] Continuous improvement of agent effectiveness
- [ ] Regular audits and updates
- [ ] Knowledge base expansion

## Metrics & KPIs

### Project Health Indicators
- Open issues count
- PR review turnaround time
- Test coverage percentage
- Documentation completeness score
- Days since last commit
- Security vulnerability count
- Dependency freshness

### Agent Performance Metrics
- Tasks completed per week
- First-time success rate
- Revision requests per PR
- Time to resolution
- Code quality improvements
- Bug introduction rate

### Portfolio-Level Metrics
- Active project count
- Total test coverage
- Overall security posture
- Documentation quality
- Cross-project code reuse
- Development velocity

## Risk Mitigation

### Agent-Generated Code Risks
1. **Quality Control**
   - Mandatory automated testing
   - Human review for critical changes
   - Gradual responsibility increase

2. **Security Concerns**
   - Automated security scanning
   - Regular security audits
   - Conservative dependency updates

3. **Consistency Issues**
   - Strong conventions documentation
   - Automated style checking
   - Cross-project templates

4. **Context Loss**
   - Comprehensive documentation
   - Architectural decision records
   - Regular context file updates

## Tools & Resources

### Recommended AI Coding Agents
- **Claude Code**: For complex refactoring and feature development
- **GitHub Copilot**: For code completion and simple fixes
- **Aider**: For autonomous coding tasks
- **GPT Engineer**: For greenfield projects

### Supporting Tools
- **GitHub Actions**: CI/CD automation
- **Dependabot**: Dependency management
- **CodeQL**: Security scanning
- **SonarQube/SonarCloud**: Code quality analysis
- **Codecov**: Test coverage tracking

### Project Management
- **GitHub Projects**: Kanban boards and tracking
- **GitHub Issues**: Task and bug tracking
- **GitHub Discussions**: Architecture discussions
- **Notion/Obsidian**: Knowledge management

## Conclusion

This portfolio represents a diverse set of projects spanning multiple domains with Rust as the primary technology. The management strategy leverages AI coding agents to maintain, enhance, and validate projects efficiently while maintaining high quality standards.

Key success factors:
1. Clear project categorization and prioritization
2. Comprehensive agent context and documentation
3. Robust automation and validation pipelines
4. Balanced human-agent collaboration
5. Continuous monitoring and improvement

The phased implementation approach ensures gradual adoption, learning, and optimization of AI agent workflows across the entire project portfolio.

---

**Next Steps:**
1. Review and approve this plan
2. Begin Phase 1 implementation
3. Select pilot projects for initial agent deployment
4. Establish feedback loops and metrics collection
5. Iterate and improve based on results
